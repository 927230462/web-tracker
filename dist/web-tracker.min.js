var webTracker = (function () {
  'use strict';

  function formatTime(time) {
    return `${time}`.split(".")[0]
  }

  function onload(callback) {
    if (document.readyState === "complete") {
      callback();
    } else {
      window.addEventListener("load", callback);
    }
  }

  const clog = (text) => {
    console.log(`%c ${text}`, "color:red");
  };

  function merge(obj, target) {
    for (var key in target) {
      obj[key] = target[key];
    }
    return obj
  }

  class SendLog {
    constructor() {
      this.xhr = new XMLHttpRequest();
    }

    init(config) {
      this.appId = config.appId;
      this.host = config.host;
      this.version = config.version;
      this.project = config.host;
      this.logstore = config.host;
      this.url = `https://${config.project}.${config.host}/logstores/${config.logstore}/track`;
    }

    initData(data = {}) {
      let extraData = {
        appId: this.appId, //项目代码
        version: this.version,
        pageTitle: document.title,
        pageUrl: location.href,
        timestamp: Date.now(),
        userAgent: navigator.userAgent
      };
      let logs = { ...extraData, ...data };
      for (let key in logs) {
        // Value in log is not string data type
        if (logs[key] === null || logs[key] === undefined) {
          logs[key] = "";
        } else if (typeof logs[key] === 'number') {
          logs[key] = "" + logs[key];
        }
        if (Object.prototype.toString.call(logs[key]) === '[object Object]') {
          logs[key] = JSON.stringify(logs[key]);
        }
      }
      return logs
    }

    validate(data) {
      if (!data.appId) {
        clog("请先设置项目代码[appId]");
        return false
      }
      if (!data.version) {
        clog("请先设置项目版本号[version]");
        return false
      }
      if (!data.logType) {
        clog("请先设置项目类型[logType]");
        return false
      }
      if (!data.logCode) {
        clog("请先设置目标对象代码[logCode]");
        return false
      }
      if (!data.logName) {
        clog("请先设置目标对象名称[logName]");
        return false
      }
      return true
    }

    send(data = {}, callback) {
      var method = data.method;
      delete data.method;
      switch (method) {
        case "GET":
          this.sendGet(data, callback);
          break
        case "IMG":
          this.sendImg(data, callback);
          break
        case "POST":
        default:
          this.sendPost(data, callback);
          break
      }
    }

    sendPost(logs = {}, callback) {
      let body = JSON.stringify({
        __logs__: [logs],
      });
      this.xhr.open("POST", this.url, true);
      this.xhr.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
      this.xhr.setRequestHeader("x-log-apiversion", "0.6.0");
      this.xhr.setRequestHeader("x-log-bodyrawsize", body.length);
      this.xhr.onload = function () {
        if ((this.status >= 200 && this.status <= 300) || this.status == 304) {
          callback && callback();
        }
      };
      this.xhr.onerror = function (error) {
        callback && callback();
        console.log("error", error);
      };
      this.xhr.send(body);
    }

    sendGet(logs = {}, callback) {
      let str = "";
      Object.keys(logs).forEach(function (key) {
        str += "&" + key + "=" + logs[key];
      });
      let url = `https://${this.project}.${this.host}/logstores/${this.logstore}/track_ua.gif?APIVersion=0.6.0` + str;

      this.xhr.open("GET", url, true);
      this.xhr.onload = function () {
        if ((this.status >= 200 && this.status <= 300) || this.status == 304) {
          callback && callback();
        }
      };
      this.xhr.onerror = function (error) {
        callback && callback();
        console.log("error", error);
      };
      this.xhr.send();
    }

    sendImg(logs = {}, callback) {
      var str = "";
      Object.keys(logs).forEach(function (key) {
        str += "&" + key + "=" + logs[key];
      });
      var img = document.createElement("img");
      img.setAttribute("class", "img-responsive");
      img.src = `https://${this.project}.${this.host}/logstores/${this.logstore}/track_ua.gif?APIVersion=0.6.0` + str;
      img.onload = () => {
        callback && callback();
      };
      img.onerror = (error) => {
        callback && callback();
        console.log("error", error);
      };
    }
  }

  const log$1 = new SendLog();

  class ExcuteQueue {
    constructor() {
      this.state = "NULL";
      this.list = [];
      this.timer = null;
    }

    excute() {
      if (this.timer) {
        console.log('excute clear');
        clearTimeout(this.timer);
      }
      this.timer = setTimeout(() => {
        if (this.list.length === 0) {
          this.state = "NULL";
          return
        }
        var item = this.list.shift();
        this.state = "RUNING";
        log$1.send(item.data, () => {
          this.state = "NULL";
          if (item.callback && typeof item.callback == "function") {
            item.callback();
          }
          this.excute(); // 继续执行下一个
        });
      }, 3000);
    }

    run(data, callback) {
      let logs = log$1.initData(data);
      //校验发送的格式是否合格
      if (!log$1.validate(logs)) {
        return
      }
      // 同样的报错 不继续提交
      if (logs.message) {
        let index = this.list.findIndex(item => item.data.message === logs.message);
        if (index >= 0) {
          return
        }
      }
      this.list.push({
        data: logs,
        callback
      });
      if (this.state !== "RUNING") {
        this.excute();
      }
    }
  }

  const excuteQueue = new ExcuteQueue();

  let lastEvent$1
  ;["click", "pointerdown", "touchstart", "mousedown", "keydown", "mouseover"].forEach((event) => {
    document.addEventListener(
      event,
      (event) => {
        lastEvent$1 = event;
      },
      {
        capture: true, //capture 控制监听器是在捕获阶段执行还是在冒泡阶段执行
        passive: true, //passive 的意思是顺从的，表示它不会对事件的默认行为说 no
      }
    );
  });

  function getLastEvent() {
    return lastEvent$1
  }

  const getSelectorDom = function (path) {
    return path
      .reverse()
      .filter(function (element) {
        return element !== window && element !== document
      })
      .map(function (element) {
        var selector;
        if (element.id) {
          selector = `#${element.id}`;
        } else if (element.className && typeof element.className === "string") {
          selector =
            "." +
            element.className
              .split(" ")
              .filter(function (item) {
                return !!item
              })
              .join(".");
        } else {
          selector = element.nodeName;
        }
        return selector
      })
      .join(" ")
  };

  function getSelector$1(pathsOrTarget) {
    if (Array.isArray(pathsOrTarget)) {
      return getSelectorDom(pathsOrTarget)
    } else {
      var paths = [];
      var element = pathsOrTarget;
      while (element) {
        paths.push(element);
        element = element.parentNode;
      }
      return getSelectorDom(paths)
    }
  }

  function injectJsError() {
    window.addEventListener(
      "error",
      function (event) {
        let lastEvent = getLastEvent();
        if (event.target && (event.target.src || event.target.href)) {
          excuteQueue.run({
            logType: "monitor",
            logCode: "RESOURCE_ERROR",
            logName: "资源加载错误",
            filename: event.target.src || event.target.href,
            tagName: event.target.tagName,
            elementType: getSelector$1(event.path || event.target),
          });
        } else {
          excuteQueue.run({
            logType: "monitor",
            logCode: "JS_ERROR",
            logName: "JS错误",
            message: event.message,
            filename: event.filename,
            position: (event.lineno || 0) + ":" + (event.colno || 0),
            stack: event.error && event.error.stack,
            elementType: lastEvent ? getSelector$1(lastEvent.path || lastEvent.target) : "",
          });
        }
      },
      true
    ); // true代表在捕获阶段调用,false代表在冒泡阶段捕获,使用true或false都可以

    //当Promise 被 reject 且没有 reject 处理器的时候，会触发 unhandledrejection 事件
    window.addEventListener(
      "unhandledrejection",
      function (event) {
        let lastEvent = getLastEvent();
        let message = "";
        let line = 0;
        let column = 0;
        let file = "";
        let stack = "";
        if (typeof event.reason === "string") {
          message = event.reason;
        } else if (typeof event.reason === "object") {
          message = event.reason.message;
        }
        let reason = event.reason;
        if (typeof reason === "object") {
          if (reason.stack) {
            var matchResult = reason.stack.match(/at\s+(.+):(\d+):(\d+)/);
            if (matchResult) {
              file = matchResult[1];
              line = matchResult[2];
              column = matchResult[3];
            }
            stack = reason.stack;
          }
        }
        excuteQueue.run({
          logType: "monitor",
          logCode: "PROMISE_ERROR",
          logName: "Promise错误",
          elementType: lastEvent ? getSelector$1(lastEvent.path || lastEvent.target) : "",
          message: message,
          filename: file,
          position: line + ":" + column,
          stack,
        });
      },
      true
    ); // true代表在捕获阶段调用,false代表在冒泡阶段捕获,使用true或false都可以
  }

  function injectXHR(XHR_ERROR) {
    let XMLHttpRequest = window.XMLHttpRequest;

    let oldOpen = XMLHttpRequest.prototype.open;
    XMLHttpRequest.prototype.open = function (method, url, async, user, password) {
      if (!url.match(/logstores/) && !url.match(/sockjs/)) {
        this.logData = {
          method,
          url,
          async,
          user,
          password,
        };
      }
      return oldOpen.apply(this, arguments)
    };

    let oldSend = XMLHttpRequest.prototype.send;
    XMLHttpRequest.prototype.send = function (body) {
      if (this.logData) {
        let start = Date.now();
        let handler = (type) => (event) => {
          let duration = Date.now() - start;
          let status = this.status;
          //匹配2xx或者3xx 则不提交日志
          if (/^[2|3].{2}$/.test(status)) {
            return
          }
          let statusText = this.statusText;
          excuteQueue.run({
            logType: "monitor",
            logCode: "XHR_ERROR",
            logName: "接口错误",
            elementType: "page",
            eventType: type, //LOAD ERROR ABORT
            pathname: this.logData.url,
            status: status + "-" + statusText,
            duration: "" + duration,
            response: this.response ? JSON.stringify(this.response) : "",
            params: body || "",
          });
        };
        XHR_ERROR && XHR_ERROR.LOAD && this.addEventListener("load", handler("LOAD"), false);
        XHR_ERROR && XHR_ERROR.ERROR && this.addEventListener("error", handler("ERROR"), false);
        XHR_ERROR && XHR_ERROR.ABORT && this.addEventListener("abort", handler("ABORT"), false);
      }
      oldSend.apply(this, arguments);
    };
  }

  function injectConsoleError() {
    console.error = (function (origin) {
      return function (info) {
        if (typeof info === "string") {
          excuteQueue.run({
            logType: "monitor",
            type: "ERROR",
            logCode: "CONSOLE_ERROR",
            logName: "控制台错误",
            message: info,
            elementType: "page",
          });
        } else if (typeof info === "object") {
          excuteQueue.run({
            logType: "monitor",
            logCode: "CONSOLE_ERROR",
            logName: "控制台错误",
            message: info.message,
            stack: info.stack,
            elementType: "page",
          });
        }
        origin.call(console, info);
      }
    })(console.error);
  }

  function getSelector(element) {
    var selector;
    if (element.id) {
      selector = `#${element.id}`;
    } else if (element.className && typeof element.className === "string") {
      selector =
        "." +
        element.className
          .split(" ")
          .filter(function (item) {
            return !!item
          })
          .join(".");
    } else {
      selector = element.nodeName.toLowerCase();
    }
    return selector
  }

  function injectBlankScreen() {
    const wrapperSelectors = ["body", "html", "#app"];
    let emptyPoints = 0;
    function isWrapper(element) {
      let selector = getSelector(element);
      if (wrapperSelectors.indexOf(selector) >= 0) {
        emptyPoints++;
      }
    }
    onload(function () {
      let xElements, yElements;
      for (let i = 1; i <= 9; i++) {
        xElements = document.elementsFromPoint((window.innerWidth * i) / 10, window.innerHeight / 2);
        yElements = document.elementsFromPoint(window.innerWidth / 2, (window.innerHeight * i) / 10);
        isWrapper(xElements[0]);
        isWrapper(yElements[0]);
      }
      if (emptyPoints >= 0) {
        let centerElements = document.elementsFromPoint(window.innerWidth / 2, window.innerHeight / 2);
        excuteQueue.run({
          logType: "monitor",
          logCode: "BLANK_SCREEN",
          logName: "白屏",
          emptyPoints: "" + emptyPoints,
          screen: window.screen.width + "x" + window.screen.height,
          viewPoint: window.innerWidth + "x" + window.innerHeight,
          elementType: getSelector(centerElements[0]),
        });
      }
    });
  }

  function injectPerf() {
    let FMP, LCP;
    new PerformanceObserver((entryList, observer) => {
      let perfEntries = entryList.getEntries();
      FMP = perfEntries[0];
      observer.disconnect();
    }).observe({ entryTypes: ["element"] });

    new PerformanceObserver((entryList, observer) => {
      const perfEntries = entryList.getEntries();
      const lastEntry = perfEntries[perfEntries.length - 1];
      LCP = lastEntry;
      observer.disconnect();
    }).observe({ entryTypes: ["largest-contentful-paint"] });

    new PerformanceObserver(function (entryList, observer) {
      const firstInput = entryList.getEntries()[0];
      if (firstInput) {
        let inputDelay = firstInput.processingStart - firstInput.startTime; //处理延迟
        let duration = firstInput.duration; //处理耗时
        if (firstInput > 0 || duration > 0) {
          //第一输入延迟（FID）测量用户首次与您的站点交互时的时间 //计算出的延迟时间
          excuteQueue.run({
            logType: "monitor",
            logCode: "PERFORMANCE_FIRST_INPUT_DELAY",
            logName: "第一输入延迟",
            elementType: "page",
            inputDelay: inputDelay ? formatTime(inputDelay) : 0,
            duration: duration ? formatTime(duration) : 0,
            startTime: firstInput.startTime,
          });
        }
      }
      observer.disconnect();
    }).observe({ type: "first-input", buffered: true });

    onload(function () {
      setTimeout(() => {
        const { fetchStart, connectStart, connectEnd, requestStart, responseStart, responseEnd, domLoading, domInteractive, domContentLoadedEventStart, domContentLoadedEventEnd, loadEventStart } =
          performance.timing;
        log.send({
          logType: "monitor",
          logCode: "PERFORMANCE_TMING",
          logName: "性能计时",
          elementType: "page",
          connectTime: connectEnd - connectStart, //TCP连接耗时
          ttfbTime: responseStart - requestStart, //ttfb
          responseTime: responseEnd - responseStart, //Response响应耗时
          parseDOMTime: loadEventStart - domLoading, //DOM解析渲染耗时
          domContentLoadedTime: domContentLoadedEventEnd - domContentLoadedEventStart, //DOMContentLoaded事件回调耗时
          timeToInteractive: domInteractive - fetchStart, //首次可交互时间
          loadTime: loadEventStart - fetchStart, //完整的加载时间
        });
        const FP = performance.getEntriesByName("first-paint")[0];
        const FCP = performance.getEntriesByName("first-contentful-paint")[0];

        excuteQueue.run({
          logType: "monitor",
          logCode: "PERFORMANCE_PAINT",
          logName: "首次绘制",
          elementType: "page",
          firstPaint: FP ? formatTime(FP.startTime) : 0,
          firstContentPaint: FCP ? formatTime(FCP.startTime) : 0,
          firstMeaningfulPaint: FMP ? formatTime(FMP.startTime) : 0,
          largestContentfulPaint: LCP ? formatTime(LCP.renderTime || LCP.loadTime) : 0,
        });
      }, 3000);
    });
  }

  function injectLongTask() {
    new PerformanceObserver((list) => {
      list.getEntries().forEach((entry) => {
        if (entry.duration > 100) {
          requestIdleCallback(() => {
            excuteQueue.run({
              logType: "monitor",
              logCode: "LONG_TASK",
              logName: "卡顿",
              eventType: lastEvent.type,
              startTime: formatTime(entry.startTime), // 开始时间
              duration: formatTime(entry.duration), // 持续时间
            });
          });
        }
      });
    }).observe({ entryTypes: ["longtask"] });
  }

  function injectPv() {
    var connection = navigator.connection;
    excuteQueue.run({
      logType: "monitor",
      logCode: "PV",
      logName: "PV",
      elementType: "page",
      effectiveType: connection.effectiveType, //网络环境
      rtt: connection.rtt, //往返时间
      screen: `${window.screen.width}x${window.screen.height}`, //设备分辨率
    });
    let startTime = Date.now();
    window.addEventListener(
      "unload",
      () => {
        let stayTime = Date.now() - startTime;
        excuteQueue.run({
          logType: "monitor",
          logCode: "STAY_TIME",
          logName: "在线时长",
          elementType: "page",
          stayTime,
        });
      },
      false
    );
  }

  class WebTracker {
    constructor() {
      this.logType = {
        JS_ERROR: true, // JS
        CONSOLE_ERROR: true, // 针对vue
        XHR_ERROR: {
          LOAD: true, // 接口请求
          ERROR: true, // 接口请求
          ABORT: false // 接口请求
        },
        PV: false,
        PERFORMANCE: false, // 性能
        TIME_ON_PAGE: false, // 在线时长
        LONG_TASK: false, // 卡顿
        BLANK_SCREEN: false // 白屏
      };
    }

    install(Vue, options) {
      this.init(options);
      Vue.prototype.$webTracker = this;
    }

    init(options) {
      options = options || {};
      this.logType = merge(this.logType, options.logType || {});
      options.logType = this.logType;
      this.config = options;
      log$1.init(this.config);
      this._init();
    }

    send(data, callback) {
      //发送数据时先加入执行队列
      excuteQueue.run(data, callback);
    }

    _init() {
      injectXHR(this.logType.XHR_ERROR);
      this.logType && this.logType.JS_ERROR && injectJsError();
      this.logType && this.logType.CONSOLE_ERROR && injectConsoleError();
      this.logType && this.logType.BLANK_SCREEN && injectBlankScreen();
      this.logType && this.logType.LONG_TASK && injectLongTask();
      this.logType && this.logType.PERFORMANCE && injectPerf();
      this.logType && this.logType.PV && injectPv();
    }
  }

  var index = new WebTracker();

  return index;

})();
